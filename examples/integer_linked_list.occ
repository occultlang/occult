include "../lib/printf.occ"

fn alloc_node(i64 val) i64* {
    i64* node = alloc(16); 
    if (node == 0) {
        return 0;
    }

    $node = val;            // store value
    i64* next_ptr = node + 8;
    $next_ptr = 0;          // initialize next to null

    return node;
}

fn alloc_next_node(i64* prev_node, i64 val) i64* {
    i64* new_node = alloc_node(val);
    if (new_node == 0) {
        return 0;
    }

    i64* next_ptr = prev_node + 8;
    $next_ptr = new_node;   // link prev to new

    return new_node;         // return new node (for chaining)
}

fn free_list(i64* head) i64 {
    i64* current = head;

    while (current != 0) {
        i64* next_field = current + 8;
        i64* next_node = $next_field;
        del(current);
        current = next_node;
    }

    return 0;
}

fn print_all_elems(i64* head) i64 {
    i64* current = head;

    while (current != 0) {
        print_integer($current);
        i64* next_field = current + 8;
        current = $next_field;
    }

    return 0;
}

fn sum_list(i64* head) i64 {
    i64 sum = 0;
    i64* current = head;

    while (current != 0) {
        sum = sum + $current;
        i64* next_field = current + 8;
        current = $next_field;
    }

    return sum;
}

fn main() i64 {
    i64* head = alloc_node(10); // first val: 10
    i64* n2 = alloc_next_node(head, 20); // 2nd val: 20
    i64* n3 = alloc_next_node(n2, 30);  // 3rd val: 30
    alloc_next_node(n3, 40); // 4th val: 40

    print_integer(sum_list(head)); // sum: 100
    print_all_elems(head); 

    free_list(head);

    return 0;
}
